// 已知一个树, 如何进行变换可以使其前序后序遍历结果不变?
// 1. 父子关系保持不变 --导致--> 树的层序不变, 只能在同层变换, 即交换左右子节点
//       - 孩子变成别人孩子 不可!
//       - 孩子父亲交换     不可!
// 2. 有两个子节点的节点的左右子节点不可交换
//                  A            A
//                 / \    =>    / \ 
//                B   C        C   B
//               ... ...      ...  ...
//     前序遍历  - AB**C**  =>  AC**B** ! 变了
// 3. 叶子节点无子节点
// 4. 只有一个子节点的节点交换左右子节点不影响前序后序遍历结果
//                  A            A
//                 /      =>      \ 
//                B                B
//               ...               ...
//     前序遍历  - AB**    =>  AB**
//     后序遍历  - **BA    =>  **BA

// 如何找到只有一个子节点的节点?
//        前序遍历包含 "AB", 后序遍历包含 "BA"
//        那么节点 A 只有子节点 B
// 因此我们可以找出只有一个子节点的节点数

// 每个这样的节点都可以通过交换左右子节点来形成新的树
// 总共可以形成的树的数量 = 2 * 2 * 2 ... * 2 (#2 = 只有一个子节点的节点数)

#include <bits/stdc++.h>

int
main()
{
    std::string s1, s2;
    std::cin >> s1 >> s2;
    int count = 0;
    for (int i = 0; i < s1.size() - 1; i++)
        for (int j = 1; j < s2.size(); j++)
            if (s1[i] == s2[j] && s1[i+1] == s2[j-1])
                count++;
    std::cout << (1 << count) << std::endl;
    exit(0);
}